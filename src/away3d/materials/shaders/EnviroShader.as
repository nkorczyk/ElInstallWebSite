package away3d.materials.shaders{	import away3d.containers.*;	import away3d.core.*;	import away3d.core.base.*;	import away3d.core.draw.*;	import away3d.core.math.*;	import away3d.core.render.*;	import away3d.core.utils.*;	import away3d.materials.*;		import flash.display.*;	import flash.geom.*;	import flash.utils.*;	    public class EnviroShader extends AbstractShader    {    	use namespace arcane;				protected var _enviroMap:BitmapData;		protected var _reflectiveness:Number;		protected var _width:int;		protected var _height:int;		protected var _halfWidth:int;		protected var _halfHeight:int;		protected var _colorTransform:ColorTransform;				public var mode:String;				public function get width():Number        {            return _enviroMap.width;        }		        public function get height():Number        {            return _enviroMap.height;        }                public function get enviroMap():BitmapData        {        	return _enviroMap;        }                public function set reflectiveness(val:Number):void        {            _reflectiveness = val;            _colorTransform = new ColorTransform(1, 1, 1, _reflectiveness, 0, 0, 0, 0);        }                public function get reflectiveness():Number        {        	return _reflectiveness;        }                public function EnviroShader(enviroMap:BitmapData, init:Object = null)        {        	super(init);        	            _enviroMap = enviroMap;        	            init = Init.parse(init);                        mode = init.getString("mode", "linear");            reflectiveness = init.getNumber("reflectiveness", 0.5, {min:0, max:1});                    	_width = _enviroMap.width;        	_height = _enviroMap.height;			                        _halfWidth = _width/2;            _halfHeight = _height/2;        }				internal var _enviroTransform:Matrix3D;				public override function updateMaterial(source:Object3D, view:View3D):void        {        	clearShapeDictionary();        	        	_enviroTransform = source.viewTransform;        	        	if (source.sceneTransformed || source.session.view.camera.sceneTransformed)        		clearFaceDictionary(source, view);        }				public override function clearFaceDictionary(source:Object3D, view:View3D):void        {        	for each (_faceVO in _faceDictionary) {        		if (source == _faceVO.source && view == _faceVO.view) {	        		if (!_faceVO.cleared)	        			_faceVO.clear();	        		_faceVO.invalidated = true;	        	}        	}        }                public override function renderLayer(tri:DrawTriangle, layer:Sprite):void        {        	super.renderLayer(tri, layer);			    		_shape = getShape(layer);        	_shape.blendMode = blendMode;        	_shape.transform.colorTransform = _colorTransform;    					_source.session.renderTriangleBitmap(_enviroMap, getMapping(_source, _face), tri.v0, tri.v1, tri.v2, smooth, false, _shape.graphics);						if (debug)                _source.session.renderTriangleLine(0, 0x0000FF, 1, tri.v0, tri.v1, tri.v2);        }				public function getMapping(source:Mesh, face:Face):Matrix		{    		_n0 = source.getVertexNormal(face.v0);			_n1 = source.getVertexNormal(face.v1);			_n2 = source.getVertexNormal(face.v2);        				_sxx = _enviroTransform.sxx;			_sxy = _enviroTransform.sxy;			_sxz = _enviroTransform.sxz;						_syx = _enviroTransform.syx;			_syy = _enviroTransform.syy;			_syz = _enviroTransform.syz;						eTri0x = _n0.x * _sxx + _n0.y * _sxy + _n0.z * _sxz;			eTri0y = _n0.x * _syx + _n0.y * _syy + _n0.z * _syz;			eTri1x = _n1.x * _sxx + _n1.y * _sxy + _n1.z * _sxz;			eTri1y = _n1.x * _syx + _n1.y * _syy + _n1.z * _syz;			eTri2x = _n2.x * _sxx + _n2.y * _sxy + _n2.z * _sxz;			eTri2y = _n2.x * _syx + _n2.y * _syy + _n2.z * _syz;						//calulate mapping			_mapping.a = _halfWidth*(eTri1x - eTri0x);			_mapping.b = _halfHeight*(eTri1y - eTri0y);			_mapping.c = _halfWidth*(eTri2x - eTri0x);			_mapping.d = _halfHeight*(eTri2y - eTri0y);			_mapping.tx = _halfWidth*eTri0x + _halfWidth;			_mapping.ty = _halfHeight*eTri0y + _halfHeight;            _mapping.invert();                        return _mapping;		}				internal var _specularTransform:Matrix3D;		internal var _nFace:Number3D;		internal var _nFaceTransZ:Number;				internal var specVal1:Number;		internal var specVal2:Number;		internal var specVal3:Number;		internal var specValFace:Number;				internal var coeff1:Number;		internal var coeff2:Number;		internal var coeff3:Number;				internal var _sxx:Number;     internal var _sxy:Number;     internal var _sxz:Number;        internal var _syx:Number;     internal var _syy:Number;     internal var _syz:Number;        internal var _szx:Number;     internal var _szy:Number;     internal var _szz:Number;                public override function renderShader(face:Face):void        {			//store a clone			if (_faceVO.cleared && !_parentFaceVO.updated) {				_faceVO.bitmap = _parentFaceVO.bitmap.clone();				_faceVO.bitmap.lock();			}						_faceVO.cleared = false;			_faceVO.updated = true;						_mapping = getMapping(face.parent, face);            _mapping.concat(face._dt.invtexturemapping);            			//draw into faceBitmap			_faceVO.bitmap.draw(_enviroMap, _mapping, _colorTransform, blendMode, _faceVO.bitmap.rect, smooth);        }    }}