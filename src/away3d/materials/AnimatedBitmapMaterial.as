package away3d.materials{    import away3d.core.*;    import away3d.core.draw.*;    import away3d.core.math.*;    import away3d.core.render.*;    import away3d.core.base.*    import away3d.core.utils.*;        import flash.display.*;    import flash.events.Event;    import flash.geom.*;    import flash.utils.getTimer;    /**		Note :		- Animated bitmap texture material allows faster rendering because its generates and reuses instances instead of copying/redrawing information		- this class is not suitable for long animations since it would require too much RAM usage		- If interactive movieclip properties are required, please refer to MovieMaterial	*/	    public class AnimatedBitmapMaterial extends TransformBitmapMaterial implements ITriangleMaterial, IUVMaterial    {		use namespace arcane;				private var _broadcaster:Sprite = new Sprite();		private var _playing:Boolean;		private var _index:int;				public var cache:Array;		public var loop:Boolean;		public var autoplay:Boolean;    	        public function AnimatedBitmapMaterial(movie:MovieClip, init:Object = null)        {			super(bitmap, init);						setMovie(movie);						init = Init.parse(init);			loop = init.getBoolean("loop", true);			autoplay = init.getBoolean("autoplay", true);			_index = init.getInt("_index", 0, {min:0, max:movie.totalFrames - 1});						//add event listener			if (autoplay)			play();                			//trigger first frame			if (loop || autoplay)				update();			else			_renderBitmap = _bitmap = cache[_index];    			        }                public function play():void        {        	if (!_playing) {	        	_playing = true;	        	_broadcaster.addEventListener(Event.ENTER_FRAME, update);	        }        }                public function stop():void        {        	if (_playing) {	        	_playing = false;	        	_broadcaster.removeEventListener(Event.ENTER_FRAME, update);	        }        	        }        		private function update(event:Event = null):void        {			//increment _index			if (_index < cache.length - 1)				_index++;			else if (loop)				_index = 0;			_renderBitmap = _bitmap = cache[_index];		}    			public function setMovie(_movie:MovieClip):void		{			cache = new Array();						//determine boundaries of this movie			var i:int;			var rect:Rectangle;			var minX:Number = 100000;			var minY:Number = 100000;			var maxX:Number = -100000;			var maxY:Number = -100000;						i = _movie.totalFrames;			while (i--)			{				_movie.gotoAndStop(i);				rect = _movie.getBounds(_movie);				if (minX > rect.left)				minX = rect.left;				if (minY > rect.top)				minY = rect.top;				if (maxX < rect.right)				maxX = rect.right;				if (maxY < rect.bottom)				maxY = rect.bottom;			}						//draw the cached bitmaps			var W:int = maxX - minX;			var H:int = maxY - minY;			var mat:Matrix = new Matrix(1, 0, 0, 1, -minX, -minY);			var tmp_bmd:BitmapData;			var timer:int = getTimer();			for(i=1; i<_movie.totalFrames+1; i++) {				//draw frame and store in cache				_movie.gotoAndStop(i);				tmp_bmd = new BitmapData(W, H, true, 0x00FFFFFF);				tmp_bmd.draw(_movie, mat, null, null, tmp_bmd.rect, true);				cache.push(tmp_bmd);							//error timeout for time over 2 seconds				if (getTimer() - timer > 2000) throw new Error("AnimatedBitmapMaterial contains too many frames. MovieMaterial should be used instead.");			 			}		}		      		public function setFrames(sources:Array):void        {			cache = new Array();			if (_index > sources.length - 1)				_index = sources.length - 1;						for(var i:int = 0; i<sources.length; i++){				cache.push(sources[i]);			}			_renderBitmap = _bitmap = cache[_index];		}				public function set index(f:int):void        {			_index = f;			_renderBitmap = _bitmap = cache[f];				}    }}