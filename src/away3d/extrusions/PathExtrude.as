package away3d.extrusions{		import away3d.core.base.*;	import away3d.core.math.*;	import away3d.core.utils.Init;	import away3d.materials.*; 	public class PathExtrude extends Mesh{				private var varr:Array;		 		//test		public var resultspath:Array; 		 		public function getresults():Array		{		return resultspath;		}				private function getAngle(a:Number3D, b:Number3D):Number        {            var mod1:Number =  Math.sqrt(a.x*a.x + a.y*a.y + a.z*a.z);			var mod2:Number =  Math.sqrt(b.x*b.x + b.y*b.y + b.z*b.z);        	var dot:Number = (a.x * b.x + a.y * b.y + a.z * b.z);			var ang:Number = Math.acos(dot/(mod1*mod2));            return (isNaN(ang))? 0 : ang;        }				private function arbitraryRotate(angle:Number, Pt:Number3D, rotPt:Number3D):Number3D		{			var tmp:Number3D = new Number3D();						var cos:Number = Math.cos(angle);			var sin:Number = Math.sin(angle);			 			rotPt.normalize(1);						tmp.x += (cos + (1 - cos) * rotPt.x * rotPt.x) * Pt.x;			tmp.x += ((1 - cos) * rotPt.x * rotPt.y - rotPt.z * sin) * Pt.y;			tmp.x += ((1 - cos) * rotPt.x * rotPt.z + rotPt.y * sin) * Pt.z;						tmp.y += ((1 - cos) * rotPt.x * rotPt.y + rotPt.z * sin) * Pt.x;			tmp.y += (cos + (1 - cos) * rotPt.y * rotPt.y) * Pt.y;			tmp.y += ((1 - cos) * rotPt.y * rotPt.z - rotPt.x * sin) * Pt.z;						tmp.z += ((1 - cos) * rotPt.x * rotPt.z - rotPt.y * sin) * Pt.x;			tmp.z += ((1 - cos) * rotPt.y * rotPt.z + rotPt.x * sin) * Pt.y;			tmp.z += (cos + (1 - cos) * rotPt.z * rotPt.z) * Pt.z;						return tmp;		}		 		function PathExtrude(aSegments:Array, aPoints:Array,  init:Object)		{						if(aSegments.length != 0 && aPoints.length >=2){				init = Init.parse(init);				super(init);					var subdivision:int = init.getInt("subdivision", 2, {min:2});				var scaling:Number = init.getNumber("scaling", 1);				var coverall:Boolean = init.getBoolean("coverall", true);				var recenter:Boolean = init.getBoolean("recenter", false);				var flip:Boolean = init.getBoolean("flip", false);				var closepath:Boolean = init.getBoolean("closepath", false);				var aligntopath:Boolean = init.getBoolean("aligntopath", true);				var aSegPoints:Array = getPointsOnCurve(aSegments, subdivision);								 				//test debug				this.resultspath = [];				this.resultspath = this.resultspath.concat(aSegPoints);				//end test				 				var aPointlist:Array = [];				var aSegresult:Array = [];								var atmp:Array;				var angle:Number;				 				var tmppt:Number3D = new Number3D(0,0,0);				var i:int;				var j:int;				var k:int;				 				var nextpt:Number3D;				var mag:Number;				 				for (i = 0; i <aSegPoints.length; i++) {					for(j = 0; j<aSegPoints[i].length;j++){						atmp = [];						atmp = atmp.concat(aPoints);						aPointlist = [];												if(aligntopath) {							nextpt = (j<aSegPoints[i].length -1)? aSegPoints[i][j+1]:  aSegPoints[i][j-1] ;  // (!aSegPoints[i+1][0])? aSegPoints[i][j-1] : aSegPoints[i+1][0] 							angle =  getAngle(nextpt, aSegPoints[i][j]);							//angle *= .5;							 mag = Math.sqrt(nextpt.x*nextpt.x + nextpt.y*nextpt.y + nextpt.z*nextpt.z);		  					//nextpt.normalize();						}												for (k = 0; k <atmp.length; k++) {							if(aligntopath) {								 								tmppt = (angle != 0)? arbitraryRotate(angle,aSegPoints[i][j], atmp[k]) : atmp[k];								 								/* tmppt.x *=  mag;								 tmppt.y *=  mag;								 tmppt.z *=  mag;*/																tmppt.x +=  aPoints[k].x;								tmppt.y +=  aPoints[k].y;								tmppt.z +=  aPoints[k].z;																//tmppt.x +=  aSegPoints[i][j].x;								//tmppt.y +=  aSegPoints[i][j].y;								//tmppt.z +=  aSegPoints[i][j].z;																 								aPointlist.push(tmppt);															} else{								tmppt = new Number3D(atmp[k].x+aSegPoints[i][j].x, atmp[k].y+aSegPoints[i][j].y, atmp[k].z+aSegPoints[i][j].z);								aPointlist.push(tmppt );							}						}						 						aSegresult.push(aPointlist);						 					}									}				 				generate(aSegresult, 1, scaling, coverall, closepath, flip);								if(recenter) {					movePivot( (this.minX+this.maxX)*.5,  (this.minY+this.maxY)*.5, (this.minZ+this.maxZ)*.5);				} else {					x =  aSegPoints[0][0].x;					y =  aSegPoints[0][0].y;					z =  aSegPoints[0][0].z;				}				 				type = "PathExtrude";				url = "Extrude";						} else {				trace("PathExtrude error: at least 2 number3D are required in points. Path definition requires at least 1 object with 3 parameters: {v0:number3D, anchor:number3D ,v1:number3D}, all properties being Number3D.");			} 		}		 		private function generate(aPoints:Array, subdivision:int = 1,  scaling:Number = 1, coverall:Boolean = false, closepath:Boolean = false, flip:Boolean = false):void		{				var uvlength:Number = (closepath)? aPoints.length : aPoints.length-1;						for(var i:int = 0;i<aPoints.length-1;i++){				varr = new Array();				extrudePoints(aPoints[i], aPoints[i+1], subdivision, coverall, (1/uvlength)*i, uvlength, flip);			}			if(closepath){				varr = new Array();				extrudePoints(aPoints[aPoints.length-1], aPoints[0], subdivision, coverall, (1/uvlength)*i, uvlength, flip);			}			/*			for(var i:int = 1;i<aPoints.length;i++){				varr = new Array();				extrudePoints(aPoints[i-1], aPoints[i], subdivision, coverall, (1/uvlength)*i, uvlength, flip);			}			if(closepath){				varr = new Array();				extrudePoints(aPoints[aPoints.length-1], aPoints[0], subdivision, coverall, (1/uvlength)*i, uvlength, flip);			}			*/		}			 				private function extrudePoints(points1:Array, points2:Array, subdivision:int, coverall:Boolean, vscale:Number, indexv:int, flip:Boolean):void		{						var i:int;			var j:int;			var stepx:Number;			var stepy:Number;			var stepz:Number;						var uva:UV; //downleft			var uvb:UV; //topleft			var uvc:UV; //topright			var uvd:UV; //downright						var va:Vertex;			var vb:Vertex;			var vc:Vertex;			var vd:Vertex;						var u1:Number;			var u2:Number;			var index:int = 0;			var bu:Number = 0;			var bincu:Number = 1/(points1.length-1);			var v1:Number = 0;			var v2:Number = 0;			 			for( i = 0; i < points1.length; i++){				stepx = (points2[i].x - points1[i].x) / subdivision;				stepy = (points2[i].y - points1[i].y) / subdivision;				stepz = (points2[i].z - points1[i].z)  / subdivision;								for( j = 0; j < subdivision+1; j++){					varr.push( new Vertex( points1[i].x+(stepx*j) , points1[i].y+(stepy*j), points1[i].z+(stepz*j)) );				}			}									for( i = 0; i < points1.length-1; i++){				u1 = bu;				bu += bincu;				u2 = bu;								for( j = 0; j < subdivision; j++){										v1 = (coverall)? vscale+((j/subdivision)/indexv) :  j/subdivision;					v2 = (coverall)? vscale+(( (j+1)/subdivision)/indexv) :  (j+1)/subdivision;										uva = new UV( u1 , v1);					uvb = new UV( u1 , v2 );					uvc = new UV( u2 , v2 );					uvd = new UV( u2 , v1 );											va = varr[index+j];					vb = varr[(index+j) + 1];					vc = varr[((index+j) + (subdivision + 2))];					vd = varr[((index+j) + (subdivision + 1))];					 					if(flip){						addFace(new Face(vb,va,vc, null, uvb, uva, uvc ));						addFace(new Face(vc,va,vd, null, uvc, uva, uvd));					}else{						addFace(new Face(va,vb,vc, null, uva, uvb, uvc ));						addFace(new Face(va,vc,vd, null, uva, uvc, uvd));					}				}				index += subdivision +1;			}					}				//Points segments		private function getPointsOnCurve(aSegments:Array, subdivision:int):Array 		{				var aSegPoints:Array = []			for (var i:int = 0; i < aSegments.length; i++) {				aSegPoints.push(getSegmentPoints(aSegments[i].v0, aSegments[i].anchor, aSegments[i].v1, subdivision));			}			return aSegPoints;		}				private function getNewPoint(x0:Number = 0, y0:Number = 0, z0:Number=0, aX:Number = 0, aY:Number = 0, aZ:Number=0, x1:Number = 0, y1:Number = 0, z1:Number=0, t:Number = 0):Number3D 		{			return new Number3D(x0 + t * (2 * (1 - t) * (aX - x0) + t * (x1 - x0)), y0 + t * (2 * (1 - t) * (aY - y0) + t * (y1 - y0)), z0 + t * (2 * (1 - t) * (aZ - z0) + t * (z1 - z0)));		}				private function getSegmentPoints(v0:Number3D, a:Number3D, v1:Number3D, n:Number):Array		{			var aPts:Array = [];			for (var i:int = 0; i < n; i++) {				aPts.push(getNewPoint(v0.x, v0.y, v0.z, a.x, a.y, a.z, v1.x, v1.y, v1.z, i / n));			}			return aPts;		}		 	}}