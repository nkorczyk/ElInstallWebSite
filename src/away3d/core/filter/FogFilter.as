package away3d.core.filter{    import away3d.cameras.*;    import away3d.containers.*;    import away3d.core.draw.*;    import away3d.core.render.*;    import away3d.core.utils.*;    import away3d.materials.*;        import flash.display.*;    import flash.events.*;    import flash.geom.*;    import flash.utils.*;    /** Filter that add fog from a given depth and prevents to render triangle according to their z depth value	when fog reaches endvalue	*/    public class FogFilter implements IPrimitiveFilter    {    	private var i:int;    	    	private var _primitives:Array;    	private var pri:DrawPrimitive;    	    	private var _material:IFogMaterial;    	private var _minZ:Number;    	private var _maxZ:int;    	private var _subdivisions:int;    	private var _materials:Array = [];    	    	private var _fogPrimitives:Array = [];    	private var fog:DrawFog;				public function set material(val:IFogMaterial):void		{			_material = val;		}				public function get material():IFogMaterial		{			return _material;		}				function FogFilter(init:Object = null):void		{			init = Init.parse(init);			            _material = init.getMaterial("material");            _minZ = init.getNumber("minZ", 1000, {min:0});            _maxZ = init.getNumber("maxZ", 5000, {min:0});            _subdivisions = init.getInt("subdivisions", 20, {min:1, max:50});            _materials = init.getArray("materials");                        if (!(_material is IFogMaterial))            	throw new Error("FogFilter requires IFogMaterial");                        if (!_material && !_materials.length)            	_material = new ColorMaterial(0x000000);                        //materials override subdivisions            if (!_materials.length) {            	i = _subdivisions;            	while (i--)            		_materials.push(_material.fogLayer());            } else {            	_subdivisions = _materials.length;            }                        i = _subdivisions;            while(i--) {            	(_materials[i] as IFogMaterial).alpha = 0.45*i/_subdivisions;            	fog = new DrawFog();            	fog.screenZ = _minZ + (_maxZ - _minZ)*i/(_subdivisions - 1);            	fog.material = _materials[i];            	_fogPrimitives.unshift(fog);            }		}		        public function filter(primitives:Array, scene:Scene3D, camera:Camera3D, clip:Clipping):Array        {			for each (fog in _fogPrimitives) {				fog.source = scene;				primitives.push(fog);			}						_primitives = [];						for each (pri in primitives) {				if (pri.screenZ < _maxZ)					_primitives.push(pri); 			}        	return _primitives;        }		        public function toString():String        {            return "FogFilter";        }    }}