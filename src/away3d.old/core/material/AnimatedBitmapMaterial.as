package away3d.core.material{    import away3d.core.*;    import away3d.core.draw.*;    import away3d.core.math.*;    import away3d.core.mesh.*;    import away3d.core.render.*;    import away3d.core.scene.*;    import away3d.core.utils.*;        import flash.display.*;    import flash.events.Event;    import flash.geom.*;    import flash.utils.getTimer;    /**		Note :		- Animated bitmap texture material allows faster rendering because its generates and reuses instances instead of copying/redrawing information		- this class is not suitable for long animations since it would require too much RAM usage		- If interactive movieclip properties are required, please refer to MovieMaterial	*/	    public class AnimatedBitmapMaterial extends TransformBitmapMaterial implements ITriangleMaterial, IUVMaterial    {    	use namespace arcane;    	    	private var _broadcaster:Sprite = new Sprite();    	private var isPlaying:Boolean;    	    	public var cache:Array;    	public var loop:Boolean;    	public var autoplay:Boolean;    	public var index:int;    	        public function AnimatedBitmapMaterial(movie:MovieClip, init:Object = null)        {        	super(bitmap, init);			            setMovie(movie);                        init = Init.parse(init);			loop = init.getBoolean("loop", true);			autoplay = init.getBoolean("autoplay", true);			index = init.getInt("index", 0, {min:0, max:movie.totalFrames - 1});                        //add event listener            if (autoplay)            	play();                		//trigger first frame    		update();        }                public function play():void        {        	if (!isPlaying) {	        	isPlaying = true;	        	_broadcaster.addEventListener(Event.ENTER_FRAME, update);	        }        }                public function stop():void        {        	if (isPlaying) {	        	isPlaying = false;	        	_broadcaster.removeEventListener(Event.ENTER_FRAME, update);	        }        	        }        		private function update(event:Event = null):void        {			//increment index        	if (index < cache.length - 1)        		index++;        	else if (loop)        		index = 0;							_renderBitmap = _bitmap = cache[index];		}    	    	public function setMovie(_movie:MovieClip):void    	{    		cache = new Array();    		    		//determine boundaries of this movie    		var i:int;    		var rect:Rectangle;    		var minX:Number = 100000;    		var minY:Number = 100000;    		var maxX:Number = -100000;    		var maxY:Number = -100000;    		    		i = _movie.totalFrames;    		while (i--)    		{    			_movie.gotoAndStop(i);    			rect = _movie.getBounds(_movie);    			if (minX > rect.left)    				minX = rect.left;    			if (minY > rect.top)    				minY = rect.top;    			if (maxX < rect.right)    				maxX = rect.right;    			if (maxY < rect.bottom)    				maxY = rect.bottom;    		}    		    		//draw the cached bitmaps    		var W:int = maxX - minX;			var H:int = maxY - minY;			var mat:Matrix = new Matrix(1, 0, 0, 1, -minX, -minY);			var tmp_bmd:BitmapData;			var timer:int = getTimer();    		for(i=0; i<_movie.totalFrames; i++) {    			//draw frame and store in cache    			_movie.gotoAndStop(i);    			tmp_bmd = new BitmapData(W, H, true, 0x00FFFFFF);				tmp_bmd.draw(_movie, mat, null, null, tmp_bmd.rect, true);				cache.push(tmp_bmd);								//error timeout for time over 2 seconds				if (getTimer() - timer > 2000) {					throw new Error("AnimatedBitmapMaterial contains too many frames. MovieMaterial should be used instead.");				}    		}    	}		      		public function setFrames(sources:Array):void        {			cache = new Array();			if (index > sources.length - 1)				index = sources.length - 1;						for(var i:int = 0; i<sources.length; i++){				cache.push(sources[i]);			}			_renderBitmap = _bitmap = cache[index];		}    }}